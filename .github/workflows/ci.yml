# .github/workflows/ci.yml

name: CI/CD - Build, Push, and Deploy Application

on:
  workflow_dispatch:

jobs:

  # =======================================================
  # JOB 1: Run the test suite
  # =======================================================
  lint-and-test:
    runs-on: ubuntu-latest
    steps:
      - name: 'Checkout Repository'
        uses: actions/checkout@v4

      - name: 'Set up Python'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11' # Use the same version as your Dockerfile

      - name: 'Install Dependencies'
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: 'Lint with flake8'
        run: |
          # The --exit-zero flag will report errors but will not fail the job.
          flake8 finance_tracker/ --count --show-source --statistics --exit-zero

      - name: 'Run Tests with Coverage'
        run: |
          pytest --cov=finance_tracker --cov-report=html

      - name: 'Upload Coverage Report'
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: htmlcov/
  # =======================================================
  # JOB 2: Build the Docker image and push it to GHCR
  # =======================================================
  build-and-push:
    runs-on: ubuntu-latest
    needs: lint-and-test
    permissions:
      contents: read
      packages: write # Permission for GITHUB_TOKEN to write packages
    
    outputs:
      image_tag: ${{ steps.docker_build.outputs.image_id }}
      owner_lc: ${{ steps.repo_owner_lc.outputs.name }}

    steps:
      - name: 'Checkout Repository'
        uses: actions/checkout@v4

      - name: 'Set repository owner to lowercase'
        id: repo_owner_lc
        run: echo "name=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: 'Log in to GitHub Container Registry'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ steps.repo_owner_lc.outputs.name }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 'Build and Push Docker Image'
        id: docker_build
        run: |
          LOWERCASE_REPO_NAME=$(echo '${{ github.event.repository.name }}' | tr '[:upper:]' '[:lower:]')
          IMAGE_NAME="ghcr.io/${{ steps.repo_owner_lc.outputs.name }}/${LOWERCASE_REPO_NAME}"
          # The tag is the unique git commit SHA, which is a best practice
          IMAGE_TAG="${IMAGE_NAME}:${{ github.sha }}"
          
          echo "Building and pushing: ${IMAGE_TAG}"
          docker build -t ${IMAGE_TAG} .
          docker push ${IMAGE_TAG}
          
          # Set the full image name as a job output for the next job
          echo "image_id=${IMAGE_TAG}" >> $GITHUB_OUTPUT

  # =======================================================
  # JOB 3: Migrate Production Database (NEW JOB)
  # =======================================================
  deploy-infra:
    runs-on: ubuntu-latest
    needs: build-and-push
    # This 'if' condition is key. It only runs for infra changes.
    if: needs.build-and-push.result == 'success'
    steps:
      - name: 'Checkout Repository'
        uses: actions/checkout@v4
      - name: 'Check for infrastructure file changes'
        id: path_filter
        uses: dorny/paths-filter@v3
        with:
          filters: |
            infra:
              - 'infra/**'
      - name: 'Log in to Azure'
        if: steps.path_filter.outputs.infra == 'true'
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      - name: 'Setup Terraform'
        if: steps.path_filter.outputs.infra == 'true'
        uses: hashicorp/setup-terraform@v2
      - name: 'Run Terraform Apply'
        if: steps.path_filter.outputs.infra == 'true'
        env:
          TF_VAR_db_admin_login: ${{ secrets.DB_ADMIN_LOGIN }}
          TF_VAR_db_admin_password: ${{ secrets.DB_ADMIN_PASSWORD }}
          TF_VAR_github_pat: ${{ secrets.GHCR_PAT }}
          TF_VAR_github_username: ${{ needs.build-and-push.outputs.owner_lc }}
          TF_VAR_flask_secret_key: ${{ secrets.FLASK_SECRET_KEY }}
          TF_VAR_task_secret_key: ${{ secrets.RECURRING_JOB_SECRET }}
        run: |
          echo "Infrastructure changes detected. Running terraform apply..."
          cd infra
          terraform init
          terraform apply -auto-approve -var="docker_image_to_deploy=${{ needs.build-and-push.outputs.image_tag }}"

  # =======================================================
  # JOB 4: Deploy to Azure with Conditional Logic
  # =======================================================
  migrate-and-deploy-app:
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-infra] # Depends on both previous jobs
    if: always() && needs.deploy-infra.result != 'failure' 
    steps:
      - name: 'Log in to Azure'
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: 'Update and Start the Database Migration Job'
        id: start_job
        run: |
          echo "Updating the migration job with the latest image..."
          az containerapp job update \
            --name pfa-migration-job \
            --resource-group personal-finance-app-rg \
            --image ${{ needs.build-and-push.outputs.image_tag }}
          
          echo "Starting the migration job..."
          # Start the job and capture the name of the new execution instance
          EXECUTION_NAME=$(az containerapp job start \
            --name pfa-migration-job \
            --resource-group personal-finance-app-rg \
            --query "name" -o tsv)

          echo "execution_name=$EXECUTION_NAME" >> $GITHUB_OUTPUT

      - name: 'Wait for migration job to complete'
        run: |
          echo "Waiting for job execution ${{ steps.start_job.outputs.execution_name }} to finish..."
          az containerapp job execution wait \
            --name pfa-migration-job \
            --resource-group personal-finance-app-rg \
            --job-execution-name ${{ steps.start_job.outputs.execution_name }} \
            --timeout 300
          
          echo "Checking job status..."
          STATUS=$(az containerapp job execution show \
            --name pfa-migration-job \
            --resource-group personal-finance-app-rg \
            --job-execution-name ${{ steps.start_job.outputs.execution_name }} \
            --query "properties.status" -o tsv)

          if [[ "$STATUS" != "Succeeded" ]]; then
            echo "::error::Migration job failed with status: $STATUS"
            az containerapp job execution logs --name pfa-migration-job --resource-group personal-finance-app-rg --job-execution-name ${{ steps.start_job.outputs.execution_name }}
            exit 1
          fi
          echo "Migration job completed successfully."

      - name: 'Deploy Application Update'
        run: |
          echo "Deploying new application image to webapp..."
          az containerapp update \
            --name pfa-webapp \
            --resource-group personal-finance-app-rg \
            --image ${{ needs.build-and-push.outputs.image_tag }}